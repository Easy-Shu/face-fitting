#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Nov 17 15:52:46 2017

@author: leon
"""

from mm import Bunch, onpick3, importObj, exportObj, generateFace, rotMat2angle, initialRegistration, dR_dpsi, dR_dtheta, dR_dphi, initialShapeCost, initialShapeGrad, shapeCost, shapeGrad, 
from time import clock
import glob, os, re, json
import numpy as np
from scipy.interpolate import interpn
from scipy.optimize import minimize, check_grad, least_squares
from scipy.linalg import rq
from sklearn.neighbors import NearestNeighbors
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from mayavi import mlab
#import visvis as vv
from pylab import savefig

if __name__ == "__main__":
    
    os.chdir('/home/leon/f2f-fitting/obama/volume/')
    numFrames = 2882 #2260 #3744
    
    # Load 3DMM
    m = Bunch(np.load('../../models/bfm2017.npz'))
    m.idEvec = m.idEvec[:, :, :80]
    m.idEval = m.idEval[:80]
    m.expEvec = m.expEvec[:, :, :76]
    m.expEval = m.expEval[:76]
    m.texEvec = m.texEvec[:, :, :80]
    m.texEval = m.texEval[:80]
    
    targetLandmarkInds = np.array([0, 1, 2, 3, 8, 13, 14, 15, 16, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 61, 62, 63, 65, 66, 67, 68, 69])
    sourceLandmarkInds = np.array([16203, 16235, 16260, 16290, 27061, 22481, 22451, 22426, 22394, 8134, 8143, 8151, 8156, 6986, 7695, 8167, 8639, 9346, 2345, 4146, 5180, 6214, 4932, 4158, 10009, 11032, 12061, 13872, 12073, 11299, 5264, 6280, 7472, 8180, 8888, 10075, 11115, 9260, 8553, 8199, 7845, 7136, 7600, 8190, 8780, 8545, 8191, 7837, 4538, 11679])
    
    #initRegInds = np.array([0, 1, 2, 4, 6, 7, 8, 12, 18, 21, 24, 27, 30, 33, 36, 39])
    
    #fName = 'IMG_00041'
    #fNameImgScaled = '/home/leon/vrn/examples/scaled/' + fName + '.jpg'
    #fNameImgOrig = '/home/leon/vrn/examples/' + fName + '.jpg'
    #fNameVol = '/home/leon/vrn/output/' + fName + '.raw'
    #fNameLandmarks = '/home/leon/vrn/examples/' + fName + '.txt'
    
    #fNameImgScaled = 'kobayashi/scaled.jpg'
    #fNameImgOrig = 'kobayashi/orig.jpg'
    #fNameVol = 'kobayashi/volume.raw'
    #fNameLandmarks = 'kobayashi/landmarks.txt'
    
    #os.chdir('/home/leon/f2f-fitting/kao/volume/')
    #for file in glob.glob('*.raw'):
    #    fName = os.path.splitext(file)[0]
    #    fNameImgOrig = '../orig/' + fName + '.jpg'
    #    fNameVol = '../volume/' + fName + '.raw'
    #    fNameLandmarks = '../landmarks/' + fName + '.txt'
    #    
    #    '''
    #    Preprocess landmark locations: map to cropped/scaled version of image
    #    '''
    #    
    #    # Read the landmarks generated by VRN and the original JSON landmarks
    #    if fNameLandmarks.endswith('.txt'):
    #        with open(fNameLandmarks, 'r') as fd:
    #            lm = []
    #            for l in fd:
    #                lm.append([int(coord) for coord in l.split(',')])
    #        lm = np.array(lm)
    #    elif fNameLandmarks.endswith('.json'):
    #        with open(fNameLandmarks, 'r') as fd:
    #            lm = json.load(fd)
    #        lm = np.array([l[0] for l in lm], dtype = int).squeeze()[:, :3]
    #        lmConf = lm[:, -1]
    #        lm = lm[:, :2]
    #    
    #    # Map the landmarks from the original image to the scaled and cropped image
    #    imgOrig = mpimg.imread(fNameImgOrig)
    #    
    #    lmRange = np.ptp(lm, axis = 0)
    #    scale = 90 / np.sqrt(lmRange.prod())
    #    cropCorner = (np.min(lm, axis = 0) - lmRange / 2) * scale
    #    
    #    scaledImgDim = np.array(imgOrig.shape[1::-1]) * scale
    #    
    #    # Case 1: The cropped picture is contained within the scaled image
    #    if (cropCorner >= 0).all() and ((192 + cropCorner) < scaledImgDim).all():
    #        lmScaled = lm * scale - cropCorner
    #    
    #    # Case 2: The crop corner is outside of the scaled image, but the extent of the cropped picture is within the bounds of the scaled image
    #    elif (cropCorner < 0).any() and ((192 + cropCorner) < scaledImgDim).all():
    #        lmScaled = lm * scale - cropCorner * (cropCorner > 0) - cropCorner * (cropCorner < 0) / 2
    #    
    #    # Case 3: The crop corner is outside of the scaled image, and the extent of the cropped picture is beyond the bounds of the scaled image
    #    elif (cropCorner < 0).any() and ((192 + cropCorner) > scaledImgDim).any():
    #        lmScaled = lm * scale - cropCorner * (cropCorner > 0) + (192 - (scaledImgDim - cropCorner * (cropCorner > 0))) / 2
    #    
    #    vol = np.fromfile(fNameVol, dtype = np.int8)
    #    vol = vol.reshape((200, 192, 192))
    #    target = np.argmax(vol[::-1, :, :] > 0, axis = 0)
    #    target = target / 2
    #    
    #    np.save('../landmarks_scaled/' + fName, lmScaled)
    #    np.save('../depth/' + fName, target)
    
#    plt.ion()
    plt.ioff()
    param = np.zeros((numFrames, m.idEval.size + m.expEval.size + 7))
    TS2orig = np.zeros((numFrames, 4))
    wVer = 10
    wLan = 50
    wReg = 1
    
    with open('../crop.tmp', 'r') as fd:
        crop = []
        for l in fd:
            crop.append([float(x) for x in l.split(' ')[1:]])
    crop = np.array(crop)
    
#    for frame, file in enumerate(glob.glob('*.raw')):
#        fName = os.path.splitext(file)[0]
#        print(fName)
#        frame -= 1
#        fNameImgOrig = '../orig/' + fName + '.png'
#        fNameVol = '../volume/' + fName + '.raw'
#        fNameLandmarks = '../landmark/' + fName + '.json'
    for frame in np.arange(1, numFrames + 1):
        print(frame)
    #    fName = '{:0>5}'.format(frame * 10)
        fName = '{:0>5}'.format(frame)
        fNameImgScaled = '../scaled/' + fName + '.png'
        fNameImgOrig = '../orig/' + fName + '.png'
        fNameVol = '../volume/' + fName + '.raw'
#        fNameLandmarks = 'obama/landmark/' + fName + '.txt'
        fNameLandmarks = '../landmark/' + fName + '.json'
#        fNameLandmarksScaled = '../landmarkScaled/' + fName + '.json'
        
        '''
        Preprocess landmark locations: map to cropped/scaled version of image
        '''
        
        # Read the landmarks generated by VRN and the original JSON landmarks
        if fNameLandmarks.endswith('.txt'):
            with open(fNameLandmarks, 'r') as fd:
                lm = []
                for l in fd:
                    lm.append([int(coord) for coord in l.split(',')])
            lm = np.array(lm)
        elif fNameLandmarks.endswith('.json'):
            with open(fNameLandmarks, 'r') as fd:
                lm = json.load(fd)
            lm = np.array([l[0] for l in lm], dtype = int).squeeze()[:, :3]
            lmConf = lm[:, -1]
            lm = lm[:, :2]
            
        # Map the landmarks from the original image to the scaled and cropped image
        imgOrig = mpimg.imread(fNameImgOrig)
#        plt.figure()
#        plt.imshow(imgOrig)
#        plt.scatter(lm[:, 0], lm[:, 1], s = 2)
#        plt.title(fName)
#        if not os.path.exists('../landmarkPicOrig'):
#            os.makedirs('../landmarkPicOrig')
#        savefig('../landmarkPicOrig/' + fName + '.png', bbox_inches='tight')
#        plt.close('all')
#        continue
    
#        lmRange = np.ptp(lm, axis = 0)
#        scale = 90 / np.sqrt(lmRange.prod())
#        cropCorner = np.rint((np.min(lm, axis = 0) - lmRange / 2) * scale)
        
        scale = 0.01 * crop[frame - 1, -1]
        cropCorner = np.rint(crop[frame - 1, :2])
        
        scaledImgDim = np.rint(np.array(imgOrig.shape[1::-1]) * scale)
        
        # Case 1: The cropped picture is contained within the scaled image
        if (cropCorner >= 0).all() and ((192 + cropCorner) < scaledImgDim).all():
            lmScaled = lm * scale - cropCorner
            case = 1
        
        # Case 2: The crop corner is outside of the scaled image, but the extent of the cropped picture is within the bounds of the scaled image
        elif (cropCorner < 0).any() and ((192 + cropCorner) < scaledImgDim).all():
            lmScaled = lm * scale - cropCorner * (cropCorner > 0) - cropCorner * (cropCorner < 0) / 2
            case = 2
        
        # Case 3: The crop corner is outside of the scaled image, and the extent of the cropped picture is beyond the bounds of the scaled image
        elif (cropCorner < 0).any() and ((192 + cropCorner) > scaledImgDim).any():
            lmScaled = lm * scale - cropCorner * (cropCorner > 0) + (192 - (scaledImgDim - cropCorner * (cropCorner > 0))) / 2
            case = 3
        
        # Plot scaled landmarks
        imgScaled = mpimg.imread(fNameImgScaled)
#        fig, ax = plt.subplots()
#        plt.imshow(imgScaled)
#        plt.hold(True)
#        x = lmScaled[:, 0]
#        y = lmScaled[:, 1]
#        ax.scatter(x, y, s = 2, c = 'b', picker = True)
#        fig.canvas.mpl_connect('pick_event', onpick3)
        
#        plt.figure()
#        plt.imshow(imgScaled)
#        plt.scatter(lmScaled[:, 0], lmScaled[:, 1], s = 2)
#        plt.title(fName + '_' + str(case))
#        if not os.path.exists('../landmarkPic'):
#            os.makedirs('../landmarkPic')
#        savefig('../landmarkPic/' + fName + '.png', bbox_inches='tight')
#        plt.close('all')
#        continue
        
        '''
        Initial registration
        '''
        
        # Import volume and rescale the z-axis by 1/2
        vol = np.fromfile(fNameVol, dtype = np.int8)
        vol = vol.reshape((200, 192, 192))
        
        # Interpolate the max volume values at the landmarks
        depth = np.argmax(vol[::-1, :, :] > 0, axis = 0) / 2
        depth2 = depth.copy()
        depth2[depth == 0] = np.max(depth)
        lmScaled = lmScaled[targetLandmarkInds, :]
        targetLandmarks = np.c_[lmScaled, interpn((np.arange(0, 192), np.arange(0, 192)), depth2, lmScaled[:, ::-1], method = 'nearest')]
#        nzd = targetLandmarks[:, 2] != 0
#        targetLandmarks = targetLandmarks[nzd, :]
    
        # Initialize shape coefficients
        # Find initial guess of the rigid transformation (rotation, translation, scale) based off of the mean face of the 3DMM
        
        if frame == 1:
            rho = initialRegistration(m.idMean[:, sourceLandmarkInds], targetLandmarks)
            P = np.r_[np.zeros(m.idEval.size + m.expEval.size), rho]
            
#            grad = check_grad(initialShapeCost, initialShapeGrad, P, targetLandmarks, m, sourceLandmarkInds)
            
            initFit = minimize(initialShapeCost, P, args = (targetLandmarks, m, sourceLandmarkInds, (wLan, wReg)), jac = initialShapeGrad)
            P = initFit.x
            
#            source = generateFace(P, m)
#            plt.figure()
#            plt.imshow(imgScaled)
#            plt.scatter(source[0, sourceLandmarkInds], source[1, sourceLandmarkInds], s = 1)
        else:
            P[-7:] = initialRegistration(generateFace(np.r_[P[:m.idEval.size + m.expEval.size], np.zeros(6), 1], m, ind = sourceLandmarkInds), targetLandmarks)
        
        '''
        Optimization
        '''
        
        # Nearest neighbors fitting from scikit-learn to form correspondence between target vertices and source vertices during optimization
        xv, yv = np.meshgrid(np.arange(192), np.arange(192))
        target = np.c_[xv.flatten(), yv.flatten(), depth.flatten()][np.flatnonzero(depth), :]
        NN = NearestNeighbors(n_neighbors = 1, metric = 'l2')
        NN.fit(target)
        
#        grad = check_grad(shapeCost, shapeGrad, P, m, target, targetLandmarks, sourceLandmarkInds, NN, False)
        
        if frame <= 20:
            
            optFit = minimize(shapeCost, P, args = (m, target, targetLandmarks, sourceLandmarkInds, NN, (wVer, wLan, wReg), True), jac = shapeGrad, options = {'maxiter': 40})
            P = optFit['x']
        
        else:
            
            optFit = minimize(shapeCost, P, args = (m, target, targetLandmarks, sourceLandmarkInds, NN, (wVer, wLan, wReg), False), jac = shapeGrad, options = {'maxiter': 40})
            P = optFit['x']
        
#        source = generateFace(P, m)
#        plt.figure()
#        plt.imshow(imgScaled)
#        plt.scatter(source[0, :], source[1, :], s = 1)
#        
#        plt.figure()
#        plt.imshow(imgScaled)
#        plt.scatter(source[0, sourceLandmarkInds], source[1, sourceLandmarkInds], s = 1)
#        break
#        plt.title(fName + '_' + str(case))
#        if not os.path.exists('../landmarkOptPic'):
#            os.makedirs('../landmarkOptPic')
#        savefig('../landmarkOptPic/' + fName + '.png', bbox_inches='tight')
#        plt.close('all')
        
        """
        Transform translate and scale parameters for original image
        """
        
        # Save the parameters for the cropped/scaled image
        param[frame - 1, :] = P
        
        # Re-scale to original input image
        TS2orig[frame - 1, -1] = P[-1] / scale
        
        # Translate to account for original image dimensions
        # Case 1: The cropped picture is contained within the scaled image
        if (cropCorner >= 0).all() and ((192 + cropCorner) < scaledImgDim).all():
            TS2orig[frame - 1, :2] = (P[-4: -2] + cropCorner) / scale
        
        # Case 2: The crop corner is outside of the scaled image, but the extent of the cropped picture is within the bounds of the scaled image
        elif (cropCorner < 0).any() and ((192 + cropCorner) < scaledImgDim).all():
            TS2orig[frame - 1, :2] = (P[-4: -2] + cropCorner * (cropCorner > 0) + cropCorner * (cropCorner < 0) / 2) / scale
        
        # Case 3: The crop corner is outside of the scaled image, and the extent of the cropped picture is beyond the bounds of the scaled image
        elif (cropCorner < 0).any() and ((192 + cropCorner) > scaledImgDim).any():
            TS2orig[frame - 1, :2] = (P[-4: -2] + cropCorner * (cropCorner > 0) - (192 - (scaledImgDim - cropCorner * (cropCorner > 0))) / 2) / scale
        
#        source = generateFace(np.r_[P[:m.idEval.size + m.expEval.size + 3], TS2orig[frame - 1, :]], m)
#        plt.figure()
#        plt.imshow(imgOrig)
#        plt.scatter(source[0, :], source[1, :], s = 1)
#        
#        plt.figure()
#        plt.imshow(imgOrig)
#        plt.scatter(source[0, sourceLandmarkInds], source[1, sourceLandmarkInds], s = 1)
#        break

#    np.save('../new/param', param)
#    np.save('../new/paramRTS2Orig', np.c_[param[:, :m.idEval.size + m.expEval.size + 3], TS2orig])
#    np.save('../new/paramWithoutRTS', np.c_[param[:, :m.idEval.size + m.expEval.size], np.zeros((numFrames, 6)), np.ones(numFrames)])
#    np.save('../new/RTS', np.c_[param[:, -7: -4], TS2orig])
    
##    source = generateFace(P, m)
#    #exportObj(generateFace(np.r_[np.zeros(m.idEval.size + m.expEval.size), rho], m), f = m.face, fNameOut = 'initReg')
#    exportObj(source, f = m.face, fNameOut = '../source')
##    exportObj(source[:, sourceLandmarkInds], fNameOut = 'sourceLandmarks')
#    #exportObj(target, fNameOut = 'target')
#    #exportObj(targetLandmarks, fNameOut = 'targetLandmarks')
#    
#
#    param = np.load('../paramRTS2Orig.npy')
#    if not os.path.exists('../shapes'):
#        os.makedirs('../shapes')
#    for shape in range(numFrames):
#        fName = '{:0>5}'.format(shape + 1)
#        exportObj(generateFace(np.r_[param[shape, :m.idEval.size + m.expEval.size], np.zeros(6), 1], m), f = m.face, fNameOut = '../shapes/' + fName)
    
#    param = np.load('../paramWithoutRTS.npy')
    
    
#    shape = generateFace(np.r_[param[0, :m.idEval.size + m.expEval.size], np.zeros(6), 1], m)
#    tmesh = mlab.triangular_mesh(shape[0, :], shape[1, :], shape[2, :], m.face, scalars = np.arange(m.numVertices), color = (1, 1, 1))
##    view = mlab.view()
#    
#    if not os.path.exists('../shapePic'):
#        os.makedirs('../shapePic')
#    for frame in range(100):
#        fName = '{:0>5}'.format(frame + 1)
#        shape = generateFace(np.r_[param[frame, :m.idEval.size + m.expEval.size], np.zeros(6), 1], m)
#        
##        mlab.options.offscreen = True
#        tmesh = mlab.triangular_mesh(shape[0, :], shape[1, :], shape[2, :], m.face, scalars = np.arange(m.numVertices), color = (1, 1, 1))
#        mlab.view(view[0], view[1], view[2], view[3])
#        mlab.savefig('../shapePic/' + fName + '.png', figure = mlab.gcf())
#        mlab.close(all = True)
    
    
    ##    shape = np.load('/home/leon/f2f-fitting/kao3/depth/meshPoints/Adam_Freier_0001.npy')
##    depth = np.load('/home/leon/f2f-fitting/kao3/depth/Adam_Freier_0001.npy')
    
#    from mpl_toolkits.mplot3d import Axes3D
#    fig = plt.figure()
#    ax = plt.axes(projection='3d')
#    xv, yv = np.meshgrid(np.arange(192), np.arange(192))
#    ax.scatter(xv, yv, depth, s = 0.1, c = 'b')
#    ax.set_xlabel('X')
#    ax.set_ylabel('Y')
#    ax.set_zlabel('Z')
    
    #im = vv.imread(fNameImgScaled)
    #
    #t = vv.imshow(im)
    #t.interpolate = True # interpolate pixels
    #
    ## volshow will use volshow3 and rendering the isosurface if OpenGL
    ## version is >= 2.0. Otherwise, it will show slices with bars that you
    ## can move (much less useful).
    #volRGB = np.stack(((vol > 1) * im[:,:,0],
    #                   (vol > 1) * im[:,:,1],
    #                   (vol > 1) * im[:,:,2]), axis=3)
    #
    #v = vv.volshow(vol > 1, renderStyle='iso')
    #
    #l0 = vv.gca()
    #l0.light0.ambient = 0.9 # 0.2 is default for light 0
    #l0.light0.diffuse = 1.0 # 1.0 is default
    #
    #a = vv.gca()
    #a.camera.fov = 0 # orthographic
    #
    #vv.use().Run()
